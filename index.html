<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Territory Capture</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.55.2/phaser.min.js"></script>
</head>
<body>
    <script>
        const API_URL = "ВАШ_СЕРВЕРНЫЙ_URL";

        const config = {
            type: Phaser.AUTO,
            width: 800,
            height: 600,
            physics: { default: 'arcade' },
            scene: { preload, create, update }
        };

        let player, cursors, enemies = [], trail = [], capturedArea = 0, capturedZones = [];
        let gameOver = false, scoreText, graphics, background;

        const game = new Phaser.Game(config);

        function preload() {
            this.load.image('player', 'https://popolzenx86.github.io/zenpop/player.png');
            this.load.image('enemy', 'https://popolzenx86.github.io/zenpop/enemy.png');
            this.load.image('background', 'https://popolzenx86.github.io/zenpop/background.png');
        }

        function create() {
            background = this.add.image(400, 300, 'background');
            background.setAlpha(0); 
            
            this.add.rectangle(400, 300, 800, 600, 0x555555);
            graphics = this.add.graphics({ lineStyle: { width: 2, color: 0xff0000 } });

            player = this.physics.add.sprite(32, 32, 'player').setCollideWorldBounds(true);
            
            for (let i = 0; i < 1; i++) {
                let enemy = this.physics.add.sprite(Phaser.Math.Between(200, 600), Phaser.Math.Between(100, 500), 'enemy');
                enemy.setVelocity(Phaser.Math.Between(-100, 100), Phaser.Math.Between(-100, 100));
                enemy.setBounce(1).setCollideWorldBounds(true);
                enemies.push(enemy);
            }
            
            cursors = this.input.keyboard.createCursorKeys();
            scoreText = this.add.text(20, 20, 'Captured: 0%', { fontSize: '24px', fill: '#fff' });
            this.physics.add.overlap(player, enemies, hitEnemy, null, this);
        }

        function update() {
            if (gameOver) return;
            
            player.setVelocity(0);
            if (cursors.left.isDown) player.setVelocityX(-200);
            if (cursors.right.isDown) player.setVelocityX(200);
            if (cursors.up.isDown) player.setVelocityY(-200);
            if (cursors.down.isDown) player.setVelocityY(200);
            
            if (!onCapturedZone(player.x, player.y)) {
                trail.push({ x: player.x, y: player.y });
            }
            
            drawTrail();
            
            if (playerOnBorder()) {
                checkCapture();
                trail = [];
            }
        }

        function drawTrail() {
            graphics.clear();
            graphics.beginPath();
            trail.forEach((point, index) => {
                if (index === 0) {
                    graphics.moveTo(point.x, point.y);
                } else {
                    graphics.lineTo(point.x, point.y);
                }
            });
            graphics.strokePath();
        }

        function playerOnBorder() {
            return player.x <= 5 || player.x >= 795 || player.y <= 5 || player.y >= 595;
        }

        function hitEnemy(player, enemy) {
            gameOver = true;
            scoreText.setText('Game Over!');
            saveScore(capturedArea);
        }

        function checkCapture() {
            if (trail.length > 2) {
                capturedZones.push([...trail]);
                capturedArea = calculateCapturedPercentage();
                scoreText.setText(`Captured: ${capturedArea}%`);
                let newAlpha = capturedArea / 100;
                background.setAlpha(newAlpha > 1 ? 1 : newAlpha);
                if (capturedArea >= 75) {
                    gameOver = true;
                    scoreText.setText('You Win!');
                    saveScore(capturedArea);
                }
            }
        }

        function onCapturedZone(x, y) {
            return capturedZones.some(zone => zone.some(point => Math.abs(point.x - x) < 5 && Math.abs(point.y - y) < 5));
        }

        function calculateCapturedPercentage() {
            let totalArea = 800 * 600;
            let capturedPixels = capturedZones.reduce((acc, zone) => acc + zone.length, 0);
            return Math.min((capturedPixels / totalArea) * 100, 100);
        }

        function saveScore(captured) {
            fetch(API_URL, {
                method: "POST",
                body: JSON.stringify({ userId: "12345", captured }),
                headers: { "Content-Type": "application/json" },
            });
        }
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Classic Xonix Debug</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.55.2/phaser.min.js"></script>
</head>
<body>
    <div style="position: absolute; left: 820px; top: 10px; width: 250px; font-family: monospace; font-size: 14px; color: white; background: black; padding: 10px;">
        <h3>Debug Info</h3>
        <p id="fps">FPS: 0</p>
        <p id="captured">Captured: 0%</p>
        <p id="floodFill">FloodFill: Idle</p>
        <p id="fillSize">Fill Size: 0</p>
    </div>
    <script>
        const API_URL = "ВАШ_СЕРВЕРНЫЙ_URL";

        const config = {
            type: Phaser.AUTO,
            width: 800,
            height: 600,
            physics: { default: 'arcade' },
            scene: { preload, create, update }
        };

        let player, cursors, enemies = [], trail = [], field = [];
        let gameOver = false, scoreText, graphics, background;
        let floodFillRunning = false;
        const cellSize = 10;
        const cols = 80, rows = 60;

        const game = new Phaser.Game(config);

        function preload() {
            this.load.image('player', 'https://popolzenx86.github.io/zenpop/player.png');
            this.load.image('enemy', 'https://popolzenx86.github.io/zenpop/enemy.png');
            this.load.image('background', 'https://popolzenx86.github.io/zenpop/background.png');
        }

        function create() {
            background = this.add.tileSprite(400, 300, 800, 600, 'background');
            background.setAlpha(0); // Сначала фон невидим

            graphics = this.add.graphics();
            initField();

            // Отрисовка рамки игрового поля
            graphics.lineStyle(2, 0x00ff00, 1); // Зеленая рамка
            graphics.strokeRect(0, 0, 800, 600);

            player = this.physics.add.sprite(10, 10, 'player').setCollideWorldBounds(true);
            player.setDisplaySize(cellSize, cellSize); // Устанавливаем размер спрайта

            for (let i = 0; i < 3; i++) {
                let enemy = this.physics.add.sprite(
                    Phaser.Math.Between(200, 600),
                    Phaser.Math.Between(100, 500),
                    'enemy'
                );
                enemy.setVelocity(Phaser.Math.Between(-100, 100), Phaser.Math.Between(-100, 100));
                enemy.setBounce(1).setCollideWorldBounds(true);
                enemy.setDisplaySize(cellSize, cellSize); // Устанавливаем размер спрайта
                enemies.push(enemy);
            }

            cursors = this.input.keyboard.createCursorKeys();
            scoreText = this.add.text(20, 20, 'Captured: 0%', { fontSize: '24px', fill: '#fff' });

            this.physics.add.overlap(player, enemies, hitEnemy, null, this);
        }

        function update() {
            if (gameOver) return;

            document.getElementById('fps').innerText = `FPS: ${Math.round(game.loop.actualFps)}`;

            player.setVelocity(0);

            if (cursors.left.isDown) player.setVelocityX(-200);
            if (cursors.right.isDown) player.setVelocityX(200);
            if (cursors.up.isDown) player.setVelocityY(-200);
            if (cursors.down.isDown) player.setVelocityY(200);

            // Добавляем текущую позицию игрока в трейл
            if (player.body.velocity.x !== 0 || player.body.velocity.y !== 0) {
                trail.push({ x: player.x, y: player.y });
            }

            if (trail.length > 0 && isPlayerOnBorder(player.x, player.y)) {
                captureArea();
                trail = [];
            }

            drawField();
            drawTrail();
        }

        function initField() {
            for (let y = 0; y < rows; y++) {
                field[y] = [];
                for (let x = 0; x < cols; x++) {
                    field[y][x] = 0; // 0 - свободная клетка, 1 - захваченная
                }
            }
        }

        function drawField() {
            graphics.clear();
            // Отрисовка рамки игрового поля
            graphics.lineStyle(2, 0x00ff00, 1); // Зеленая рамка
            graphics.strokeRect(0, 0, 800, 600);

            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    if (field[y][x] === 1) {
                        graphics.fillStyle(0xffffff, 1); // Белый цвет для маски
                        graphics.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                    }
                }
            }
        }

        function drawTrail() {
            if (trail.length > 1) {
                graphics.lineStyle(2, 0xff0000, 1); // Устанавливаем стиль линии
                graphics.beginPath();
                graphics.moveTo(trail[0].x, trail[0].y);
                for (let i = 1; i < trail.length; i++) {
                    graphics.lineTo(trail[i].x, trail[i].y);
                }
                graphics.strokePath();
            }
        }

        function isPlayerOnBorder(x, y) {
            let cx = Math.floor(x / cellSize);
            let cy = Math.floor(y / cellSize);
            return cx === 0 || cx === cols - 1 || cy === 0 || cy === rows - 1;
        }

        function captureArea() {
            if (trail.length < 3) return;

            trail.forEach(point => {
                let cx = Math.floor(point.x / cellSize);
                let cy = Math.floor(point.y / cellSize);
                field[cy][cx] = 1; // Помечаем клетку как захваченную
            });

            floodFill();
            updateScore();
        }

        function floodFill() {
            floodFillRunning = true;
            document.getElementById('floodFill').innerText = 'FloodFill: Running';

            let visited = new Array(rows).fill(0).map(() => new Array(cols).fill(false));
            let queue = [];
            let fillSize = 0;

            function addToQueue(x, y) {
                if (x < 0 || y < 0 || x >= cols || y >= rows) return;
                if (visited[y][x] || field[y][x] === 1) return;
                visited[y][x] = true;
                queue.push({ x, y });
            }

            enemies.forEach(enemy => {
                let cx = Math.floor(enemy.x / cellSize);
                let cy = Math.floor(enemy.y / cellSize);
                addToQueue(cx, cy);
            });

            while (queue.length > 0) {
                let { x, y } = queue.shift();
                fillSize++;

                addToQueue(x + 1, y);
                addToQueue(x - 1, y);
                addToQueue(x, y + 1);
                addToQueue(x, y - 1);

                if (fillSize > 5000) {
                    console.warn("Flood fill stopped - too large!");
                    break;
                }
            }

            document.getElementById('fillSize').innerText = `Fill Size: ${fillSize}`;

            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    if (!visited[y][x]) {
                        field[y][x] = 1; // Помечаем клетку как захваченную
                    }
                }
            }

            floodFillRunning = false;
            document.getElementById('floodFill').innerText = 'FloodFill: Idle';
        }

        function updateScore() {
            let capturedCells = field.flat().filter(v => v === 1).length;
            let totalCells = cols * rows;
            let percentage = Math.floor((capturedCells / totalCells) * 100);
            document.getElementById('captured').innerText = `Captured: ${percentage}%`;

            if (percentage >= 75) {
                gameOver = true;
                scoreText.setText('You Win!');
                saveScore();
            }
        }

        function hitEnemy() {
            gameOver = true;
            scoreText.setText('Game Over!');
            saveScore();
        }

        function saveScore() {
            let capturedCells = field.flat().filter(v => v === 1).length;
            let percentage = Math.floor((capturedCells / (cols * rows)) * 100);

            fetch(API_URL, {
                method: "POST",
                body: JSON.stringify({ userId: "12345", captured: percentage }),
                headers: { "Content-Type": "application/json" }
            });
        }
    </script>
</body>
</html>
